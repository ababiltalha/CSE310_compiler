Line 1: type_specifier : INT

int

Line 1: type_specifier : INT

int

Line 1: parameter_list : type_specifier ID

int a

Line 2: type_specifier : INT

int

Line 2: declaration_list : ID

w

Line 2: var_declaration : type_specifier declaration_list SEMICOLON

int w;

Line 2: statement : var_declaration

int w;

Line 2: statements : statement

int w;

Line 3: variable : ID

w

Line 3: factor : CONST_INT

2

Line 3: unary_expression : factor

2

Line 3: term : unary_expression

2

Line 3: variable : ID

a

Line 3: factor : variable

a

Line 3: unary_expression : factor

a

Line 3: term : term MULOP unary_expression

2*a

Line 3: simple_expression : term

2*a

Line 3: rel_expression : simple_expression

2*a

Line 3: logic_expression : rel_expression

2*a

Line 3: expression : variable ASSIGNOP logic_expression

w=2*a

Line 3: expression_statement : expression SEMICOLON

w=2*a;

Line 3: statement : expression_statement

w=2*a;

Line 3: statements : statements statement

int w;
w=2*a;

Line 4: variable : ID

w

Line 4: factor : variable

w

Line 4: unary_expression : factor

w

Line 4: term : unary_expression

w

Line 4: simple_expression : term

w

Line 4: rel_expression : simple_expression

w

Line 4: logic_expression : rel_expression

w

Line 4: expression : logic_expression

w

Line 4: statement : RETURN expression SEMICOLON

return w;

Line 4: statements : statements statement

int w;
w=2*a;
return w;

Line 5: variable : ID

a

Line 5: factor : CONST_INT

9

Line 5: unary_expression : factor

9

Line 5: term : unary_expression

9

Line 5: simple_expression : term

9

Line 5: rel_expression : simple_expression

9

Line 5: logic_expression : rel_expression

9

Line 5: expression : variable ASSIGNOP logic_expression

a=9

Line 5: expression_statement : expression SEMICOLON

a=9;

Line 5: statement : expression_statement

a=9;

Line 5: statements : statements statement

int w;
w=2*a;
return w;
a=9;

Line 6: compound_statement : LCURL statements RCURL

{
int w;
w=2*a;
return w;
a=9;
}




ScopeTable # 1.1
 7 --> < a , ID >::stackOffset=4
 29 --> < w , ID >::stackOffset=-2

ScopeTable # 1
 12 --> < f , ID >::stackOffset=0



Line 6: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int f(int a){
int w;
w=2*a;
return w;
a=9;
}




Line 6: unit : func_definition

int f(int a){
int w;
w=2*a;
return w;
a=9;
}




Line 6: program : unit

int f(int a){
int w;
w=2*a;
return w;
a=9;
}




Line 8: type_specifier : INT

int

Line 8: type_specifier : INT

int

Line 8: parameter_list : type_specifier ID

int a

Line 8: type_specifier : INT

int

Line 8: parameter_list : parameter_list COMMA type_specifier ID

int a,int b

Line 9: type_specifier : INT

int

Line 9: declaration_list : ID

x

Line 9: var_declaration : type_specifier declaration_list SEMICOLON

int x;

Line 9: statement : var_declaration

int x;

Line 9: statements : statement

int x;

Line 10: variable : ID

x

Line 10: variable : ID

a

Line 10: factor : variable

a

Line 10: unary_expression : factor

a

Line 10: term : unary_expression

a

Line 10: simple_expression : term

a

Line 10: rel_expression : simple_expression

a

Line 10: logic_expression : rel_expression

a

Line 10: arguments : logic_expression

a

Line 10: argument_list : arguments

a

Line 10: factor : ID LPAREN argument_list RPAREN

f(a)

Line 10: unary_expression : factor

f(a)

Line 10: term : unary_expression

f(a)

Line 10: simple_expression : term

f(a)

Line 10: variable : ID

a

Line 10: factor : variable

a

Line 10: unary_expression : factor

a

Line 10: term : unary_expression

a

Line 10: simple_expression : simple_expression ADDOP term

f(a)+a

Line 10: variable : ID

b

Line 10: factor : variable

b

Line 10: unary_expression : factor

b

Line 10: term : unary_expression

b

Line 10: simple_expression : simple_expression ADDOP term

f(a)+a+b

Line 10: rel_expression : simple_expression

f(a)+a+b

Line 10: logic_expression : rel_expression

f(a)+a+b

Line 10: expression : variable ASSIGNOP logic_expression

x=f(a)+a+b

Line 10: expression_statement : expression SEMICOLON

x=f(a)+a+b;

Line 10: statement : expression_statement

x=f(a)+a+b;

Line 10: statements : statements statement

int x;
x=f(a)+a+b;

Line 11: variable : ID

x

Line 11: factor : variable

x

Line 11: unary_expression : factor

x

Line 11: term : unary_expression

x

Line 11: simple_expression : term

x

Line 11: rel_expression : simple_expression

x

Line 11: logic_expression : rel_expression

x

Line 11: expression : logic_expression

x

Line 11: statement : RETURN expression SEMICOLON

return x;

Line 11: statements : statements statement

int x;
x=f(a)+a+b;
return x;

Line 12: compound_statement : LCURL statements RCURL

{
int x;
x=f(a)+a+b;
return x;
}




ScopeTable # 1.2
 0 --> < x , ID >::stackOffset=-2
 7 --> < a , ID >::stackOffset=6
 8 --> < b , ID >::stackOffset=4

ScopeTable # 1
 12 --> < f , ID >::stackOffset=0
 13 --> < g , ID >::stackOffset=0



Line 12: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int g(int a,int b){
int x;
x=f(a)+a+b;
return x;
}




Line 12: unit : func_definition

int g(int a,int b){
int x;
x=f(a)+a+b;
return x;
}




Line 12: program : program unit

int f(int a){
int w;
w=2*a;
return w;
a=9;
}


int g(int a,int b){
int x;
x=f(a)+a+b;
return x;
}




Line 14: type_specifier : INT

int

Line 15: type_specifier : INT

int

Line 15: declaration_list : ID

a

Line 15: declaration_list : declaration_list COMMA ID

a,b

Line 15: var_declaration : type_specifier declaration_list SEMICOLON

int a,b;

Line 15: statement : var_declaration

int a,b;

Line 15: statements : statement

int a,b;

Line 16: variable : ID

a

Line 16: factor : CONST_INT

1

Line 16: unary_expression : factor

1

Line 16: term : unary_expression

1

Line 16: simple_expression : term

1

Line 16: rel_expression : simple_expression

1

Line 16: logic_expression : rel_expression

1

Line 16: expression : variable ASSIGNOP logic_expression

a=1

Line 16: expression_statement : expression SEMICOLON

a=1;

Line 16: statement : expression_statement

a=1;

Line 16: statements : statements statement

int a,b;
a=1;

Line 17: variable : ID

b

Line 17: factor : CONST_INT

2

Line 17: unary_expression : factor

2

Line 17: term : unary_expression

2

Line 17: simple_expression : term

2

Line 17: rel_expression : simple_expression

2

Line 17: logic_expression : rel_expression

2

Line 17: expression : variable ASSIGNOP logic_expression

b=2

Line 17: expression_statement : expression SEMICOLON

b=2;

Line 17: statement : expression_statement

b=2;

Line 17: statements : statements statement

int a,b;
a=1;
b=2;

Line 18: variable : ID

a

Line 18: variable : ID

a

Line 18: factor : variable

a

Line 18: unary_expression : factor

a

Line 18: term : unary_expression

a

Line 18: simple_expression : term

a

Line 18: rel_expression : simple_expression

a

Line 18: logic_expression : rel_expression

a

Line 18: arguments : logic_expression

a

Line 18: variable : ID

b

Line 18: factor : variable

b

Line 18: unary_expression : factor

b

Line 18: term : unary_expression

b

Line 18: simple_expression : term

b

Line 18: rel_expression : simple_expression

b

Line 18: logic_expression : rel_expression

b

Line 18: arguments : arguments COMMA logic_expression

a,b

Line 18: argument_list : arguments

a,b

Line 18: factor : ID LPAREN argument_list RPAREN

g(a,b)

Line 18: unary_expression : factor

g(a,b)

Line 18: term : unary_expression

g(a,b)

Line 18: simple_expression : term

g(a,b)

Line 18: rel_expression : simple_expression

g(a,b)

Line 18: logic_expression : rel_expression

g(a,b)

Line 18: expression : variable ASSIGNOP logic_expression

a=g(a,b)

Line 18: expression_statement : expression SEMICOLON

a=g(a,b);

Line 18: statement : expression_statement

a=g(a,b);

Line 18: statements : statements statement

int a,b;
a=1;
b=2;
a=g(a,b);

Line 19: statement : PRINTLN LPAREN ID RPAREN SEMICOLON

println(a);

Line 19: statements : statements statement

int a,b;
a=1;
b=2;
a=g(a,b);
println(a);

Line 20: factor : CONST_INT

0

Line 20: unary_expression : factor

0

Line 20: term : unary_expression

0

Line 20: simple_expression : term

0

Line 20: rel_expression : simple_expression

0

Line 20: logic_expression : rel_expression

0

Line 20: expression : logic_expression

0

Line 20: statement : RETURN expression SEMICOLON

return 0;

Line 20: statements : statements statement

int a,b;
a=1;
b=2;
a=g(a,b);
println(a);
return 0;

Line 21: compound_statement : LCURL statements RCURL

{
int a,b;
a=1;
b=2;
a=g(a,b);
println(a);
return 0;
}




ScopeTable # 1.3
 7 --> < a , ID >::stackOffset=-2
 8 --> < b , ID >::stackOffset=-4

ScopeTable # 1
 7 --> < main , ID >::stackOffset=0
 12 --> < f , ID >::stackOffset=0
 13 --> < g , ID >::stackOffset=0



Line 21: func_definition : type_specifier ID LPAREN RPAREN compound_statement

int main(){
int a,b;
a=1;
b=2;
a=g(a,b);
println(a);
return 0;
}




Line 21: unit : func_definition

int main(){
int a,b;
a=1;
b=2;
a=g(a,b);
println(a);
return 0;
}




Line 21: program : program unit

int f(int a){
int w;
w=2*a;
return w;
a=9;
}


int g(int a,int b){
int x;
x=f(a)+a+b;
return x;
}


int main(){
int a,b;
a=1;
b=2;
a=g(a,b);
println(a);
return 0;
}




Line 21: start : program


ScopeTable # 1
 7 --> < main , ID >::stackOffset=0
 12 --> < f , ID >::stackOffset=0
 13 --> < g , ID >::stackOffset=0


Total lines: 21
Total errors: 0
